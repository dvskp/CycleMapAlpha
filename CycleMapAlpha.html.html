<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Cycling Map â€” Full Feature Build</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>

<style>
  html,body,#map{height:100%;margin:0;padding:0;font-family:system-ui,Arial}
  #map{position:relative}
  .topbar{position:absolute;left:10px;top:10px;z-index:1300;background:#fff;padding:10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.12);min-width:420px}
  .topbar h1{margin:0 0 6px 0;font-size:15px}
  .controls{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:6px;align-items:center}
  .btn{padding:6px 8px;border-radius:6px;background:#f3f4f6;border:1px solid #e5e7eb;cursor:pointer;font-size:13px}
  .btn.primary{background:#2b8a3e;color:#fff;border-color:transparent}
  .btn.cancel{background:#ef4444;color:#fff;border-color:transparent}
  .small{font-size:12px;color:#444}
  .legend{margin-top:8px}
  .legend .row{display:flex;align-items:center;gap:8px;margin:4px 0}
  .swatch{width:18px;height:12px;border-radius:3px;display:inline-block}
  .filters{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .popup-form label{display:block;margin:6px 0 2px;font-size:13px}
  .popup-form input,.popup-form textarea,.popup-form select{width:100%;box-sizing:border-box;padding:6px;font-size:13px}
  .popup-actions{display:flex;gap:8px;margin-top:8px}
  .exportBtn{background:#2563eb;color:#fff;border:none;padding:6px 8px;border-radius:6px;cursor:pointer}
  .deleteBtn{background:#ef4444;color:#fff;border:none;padding:6px 8px;border-radius:6px;cursor:pointer}
  .search-row{display:flex;gap:8px;align-items:center;margin-left:auto}
</style>
</head>
<body>
  <div id="map"></div>

  <div class="topbar" id="topbar">
    <h1>ðŸš² Cycling Map â€” Full</h1>
    <div class="controls">
      <button id="btnRoute" class="btn primary">Enable Routing</button>
      <button id="btnCancel" class="btn cancel" disabled>Cancel Start</button>

      <button id="btnSave" class="btn">Save</button>
      <button id="btnLoad" class="btn">Load</button>
      <button id="btnExportAll" class="btn">Export All</button>
      <label class="btn">Import <input id="importFile" type="file" accept="application/json" style="display:none"/></label>

      <div class="search-row">
        <select id="searchType" class="btn" style="padding:6px 8px">
          <option value="bike_shop">Bike shops</option>
          <option value="drinking_water">Water sources</option>
        </select>
        <button id="btnSearchNearby" class="btn">Search Nearby</button>
      </div>
    </div>

    <div class="legend">
      <div style="font-weight:600">Layers</div>
      <div class="row"><input id="toggleSegments" type="checkbox" checked/> <label for="toggleSegments">Segments</label></div>
      <div class="row"><input id="toggleUserPOIs" type="checkbox" checked/> <label for="toggleUserPOIs">User POIs</label></div>
      <div class="row"><input id="toggleToilets" type="checkbox" checked/> <label for="toggleToilets">Public Toilets</label></div>
      <div class="row"><input id="toggleCamps" type="checkbox" checked/> <label for="toggleCamps">Campgrounds</label></div>

      <div style="font-weight:600;margin-top:8px">POI Filters</div>
      <div class="filters">
        <label><input class="poi-filter" type="checkbox" value="toilet" checked/> Toilets</label>
        <label><input class="poi-filter" type="checkbox" value="campground" checked/> Campgrounds</label>
        <label><input class="poi-filter" type="checkbox" value="bike_shop" checked/> Bike shops</label>
        <label><input class="poi-filter" type="checkbox" value="water" checked/> Water</label>
      </div>

      <div style="font-weight:600;margin-top:8px">Segment ranking</div>
      <div class="row"><span class="swatch" style="background:#7c3aed"></span> Dedicated path</div>
      <div class="row"><span class="swatch" style="background:#16a34a"></span> Good</div>
      <div class="row"><span class="swatch" style="background:#f59e0b"></span> Okay</div>
      <div class="row"><span class="swatch" style="background:#ef4444"></span> Bad</div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
/* =========================
   Map + Layers init
   ========================= */
const map = L.map('map').setView([35.68,139.76], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'&copy; OSM contributors'}).addTo(map);

// main layers
const segmentsLayer = L.featureGroup().addTo(map);
const userPoisLayer = L.featureGroup().addTo(map);

// POI category groups (hold user POIs by category)
const poiGroups = {
  toilet: L.featureGroup(),
  campground: L.featureGroup(),
  bike_shop: L.featureGroup(),
  water: L.featureGroup()
};
// fetched clusters for Overpass results
const toiletsCluster = L.markerClusterGroup().addTo(map);
const campsCluster = L.markerClusterGroup().addTo(map);
const searchCluster = L.markerClusterGroup().addTo(map); // for search results

// map layer control (we'll manage toggles via checkboxes too)
L.control.layers(null, { "Segments": segmentsLayer, "User POIs": userPoisLayer, "Public Toilets": toiletsCluster, "Campgrounds": campsCluster }, { collapsed:false }).addTo(map);

/* =========================
   utilities
   ========================= */
function escapeHtml(s){ return (s||'').toString().replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
function styleForRank(rank){
  switch(rank){
    case 'dedicated': return { color:'#7c3aed', weight:6 };
    case 'good': return { color:'#16a34a', weight:6 };
    case 'okay': return { color:'#f59e0b', weight:6 };
    default: return { color:'#ef4444', weight:6 };
  }
}

/* =========================
   Multi-segment routing (from second file)
   ========================= */
let routingOn=false, waypoints=[], waypointMarkers=[], previewLine=null;
const btnFinish = document.createElement('button');
btnFinish.textContent="Finish Route"; btnFinish.className="btn"; btnFinish.disabled=true; document.querySelector('.controls').appendChild(btnFinish);
btnRoute.onclick=()=>{
  routingOn=!routingOn;
  if(!routingOn) clearRouting();
  btnRoute.textContent=routingOn?"Routing ON (click points)":"Enable Routing";
};
btnFinish.onclick=()=>finishRoute();
btnCancel.onclick=()=>clearRouting();

map.on('click', e=>{
  if(!routingOn) return;
  waypoints.push(e.latlng);
  const m = L.circleMarker(e.latlng,{radius:5,color:'black'}).addTo(map);
  waypointMarkers.push(m);
  btnCancel.disabled=false;
  btnFinish.disabled=false;
});

map.on('mousemove', e=>{
  if(routingOn && waypoints.length>0){
    const latlngs=[...waypoints,e.latlng];
    if(previewLine) previewLine.setLatLngs(latlngs);
    else previewLine = L.polyline(latlngs,{color:'#888',weight:3,opacity:0.7,dashArray:'6,6'}).addTo(map);
  }
});

async function finishRoute(){
  if(waypoints.length<2){alert("Need at least 2 points"); return;}
  if(previewLine){ map.removeLayer(previewLine); previewLine=null; }
  const coords=waypoints.map(p=>`${p.lng},${p.lat}`).join(";");
  const url=`https://router.project-osrm.org/route/v1/cycling/${coords}?geometries=geojson&overview=full`;
  try{
    const r=await fetch(url),d=await r.json();
    if(d.routes && d.routes.length){
      const c=d.routes[0].geometry.coordinates.map(c=>[c[1],c[0]]);
      const seg = L.polyline(c, styleForRank('good')).addTo(segmentsLayer);
      seg.feature={type:'Feature',properties:{layerType:'segment',rank:'good',name:'New segment',notes:''},geometry:d.routes[0].geometry};
      // elevation and popup
      const distKm = (d.routes[0].distance/1000).toFixed(2);
      computeElevationForCoords(c).then(stats=>bindSegmentPopupWithChart(seg, distKm, stats));
    } else alert("No route found.");
  }catch(e){alert("Route fetch failed."); console.error(e);}
  clearRouting();
}

function clearRouting(){
  waypoints=[]; waypointMarkers.forEach(m=>map.removeLayer(m)); waypointMarkers=[];
  if(previewLine){map.removeLayer(previewLine); previewLine=null;}
  btnCancel.disabled=true; btnFinish.disabled=true;
}


/* =========================
   Elevation sampling & stats via Open-Elevation
   - sample up to ~50 points along polyline
   ========================= */
async function computeElevationForCoords(latlngs){
  // latlngs: array of [lat, lng]
  // sample step to limit to ~50 points
  const maxSamples = 50;
  const step = Math.max(1, Math.floor(latlngs.length / maxSamples));
  const sampled = latlngs.filter((_, i) => i % step === 0).map(p => ({ latitude: p[0], longitude: p[1] }));
  if(sampled.length === 0) return { elevations:[], distances:[], gain:0, loss:0, sampled:[] };

  // call Open-Elevation
  try{
    const resp = await fetch('https://api.open-elevation.com/api/v1/lookup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ locations: sampled })
    });
    const json = await resp.json();
    const elevations = (json.results || []).map(r => r.elevation || 0);
    // compute ascent/descent and cumulative distances
    let gain = 0, loss = 0;
    for(let i=1;i<elevations.length;i++){
      const d = elevations[i] - elevations[i-1];
      if(d>0) gain += d; else loss += -d;
    }
    // distances between sampled points
    let dist = 0;
    const distances = [0];
    for(let i=1;i<sampled.length;i++){
      const a = sampled[i-1], b = sampled[i];
      const dx = (b.latitude - a.latitude) * 111320;
      const dy = (b.longitude - a.longitude) * (40075000 * Math.cos(b.latitude * Math.PI/180) / 360);
      dist += Math.sqrt(dx*dx + dy*dy);
      distances.push((dist/1000).toFixed(3));
    }
    return { elevations, distances, gain: Math.round(gain), loss: Math.round(loss), sampled };
  }catch(err){
    console.warn('Elevation fetch failed', err);
    return { elevations: [], distances: [], gain:0, loss:0, sampled: [] };
  }
}

/* =========================
   Segment popup: chart + CSV/GPX export + ranking + delete
   ========================= */
function bindSegmentPopupWithChart(layer, distKm, stats){
  const props = layer.feature.properties || {};
  const chartId = 'chart_' + Math.random().toString(36).slice(2,9);
  const html = `<div class="popup-form">
    <label>Name <input id="segName" value="${escapeHtml(props.name||'')}" /></label>
    <label>Rank
      <select id="segRank">
        <option value="dedicated"${props.rank==='dedicated'?' selected':''}>Dedicated path</option>
        <option value="good"${props.rank==='good'?' selected':''}>Good</option>
        <option value="okay"${props.rank==='okay'?' selected':''}>Okay</option>
        <option value="bad"${props.rank==='bad'?' selected':''}>Bad</option>
      </select>
    </label>
    <label>Notes <textarea id="segNotes">${escapeHtml(props.notes||'')}</textarea></label>
    <div style="margin-top:6px;font-size:13px"><b>Stats</b><br>
      Distance: ${distKm} km<br>
      Elev gain: ${stats.gain || 0} m<br>
      Elev loss: ${stats.loss || 0} m<br>
      Avg grade: ${ (stats.gain && distKm>0) ? ((stats.gain/(distKm*1000)*100).toFixed(2) + '%') : 'â€”' }
    </div>
    <canvas id="${chartId}" width="300" height="120"></canvas>
    <div class="popup-actions">
      <button id="segSave" class="btn">Save</button>
      <button id="segExportCSV" class="exportBtn">Export CSV</button>
      <button id="segExportGPX" class="exportBtn">Export GPX</button>
      <button id="segDelete" class="deleteBtn">Delete</button>
    </div>
  </div>`;
  layer.bindPopup(html, { maxWidth:360 });
  layer.on('popupopen', () => {
    document.getElementById('segSave').onclick = () => {
      props.name = document.getElementById('segName').value;
      props.notes = document.getElementById('segNotes').value;
      const newRank = document.getElementById('segRank').value;
      props.rank = newRank;
      layer.setStyle(styleForRank(newRank));
      layer.closePopup();
    };
    document.getElementById('segDelete').onclick = () => {
      segmentsLayer.removeLayer(layer);
    };
    // draw chart
    if(stats.elevations && stats.elevations.length){
      const ctx = document.getElementById(chartId);
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: stats.distances,
          datasets: [{ label:'Elevation (m)', data: stats.elevations, fill:true, borderColor:'#16a34a', backgroundColor:'rgba(22,163,74,0.15)', tension:0.2 }]
        },
        options: { plugins:{legend:{display:false}}, scales:{ x:{ title:{display:true,text:'Distance (km'}}, y:{ title:{display:true,text:'Elevation (m)'} } } }
      });
    }
    // CSV export
    document.getElementById('segExportCSV').onclick = () => {
      const rows = ['latitude,longitude,elevation_m,distance_km'];
      const s = stats.sampled || [];
      for(let i=0;i<s.length;i++){
        rows.push(`${s[i].latitude},${s[i].longitude},${(stats.elevations[i]||0)},${(stats.distances[i]||0)}`);
      }
      const blob = new Blob([rows.join('\n')], { type:'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = (props.name||'segment') + '.csv'; a.click(); URL.revokeObjectURL(url);
    };
    // GPX export
    document.getElementById('segExportGPX').onclick = () => {
      let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="CyclingMap">\n<trk><name>' + escapeHtml(props.name||'Segment') + '</name><trkseg>\n';
      const s = stats.sampled || [];
      for(let i=0;i<s.length;i++){
        const ele = stats.elevations[i] || 0;
        gpx += `<trkpt lat="${s[i].latitude}" lon="${s[i].longitude}"><ele>${ele}</ele></trkpt>\n`;
      }
      gpx += '</trkseg></trk>\n</gpx>';
      const blob = new Blob([gpx], { type:'application/gpx+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = (props.name||'segment') + '.gpx'; a.click(); URL.revokeObjectURL(url);
    };
  });
}

/* =========================
   User POI handling (draw / ctrl+click / draggable)
   ========================= */
// Draw tool for adding POIs
const drawControl = new L.Control.Draw({
  draw: { polygon:false, polyline:false, rectangle:false, circle:false, circlemarker:false, marker:true },
  edit: { featureGroup: userPoisLayer, remove: true }
});
map.addControl(drawControl);

// helper to add a user POI
function addUserPOI(latlng, category='bike_shop', properties={}){
  const marker = L.marker(latlng, { draggable: true });
  const props = Object.assign({ category: category, name: 'New POI', notes: '' }, properties);
  marker.feature = { type:'Feature', properties: props, geometry: { type:'Point', coordinates: [latlng.lng, latlng.lat] } };
  // add to category group and master
  poiGroups[category].addLayer(marker);
  userPoisLayer.addLayer(marker);
  bindUserPoiPopup(marker);
  // draggable -> update geometry on dragend
  marker.on('dragend', () => {
    const ll = marker.getLatLng();
    marker.feature.geometry.coordinates = [ll.lng, ll.lat];
  });
  refreshUserPoisMaster();
  return marker;
}

map.on(L.Draw.Event.CREATED, function(e){
  if(e.layer && e.layer instanceof L.Marker){
    const marker = e.layer;
    addUserPOI(marker.getLatLng(), 'bike_shop', { name:'New POI' });
  }
});

// ctrl+click quick add default bike_shop
map.on('click', e => {
  if(e.originalEvent && e.originalEvent.ctrlKey){
    addUserPOI(e.latlng, 'bike_shop', { name:'New POI' });
  }
});

// popup for user POI
function bindUserPoiPopup(marker){
  marker.on('click', () => {
    const props = marker.feature.properties || {};
    const html = `<div class="popup-form">
      <label>Name <input id="poiName" value="${escapeHtml(props.name||'')}" /></label>
      <label>Category
        <select id="poiCat">
          <option value="toilet"${props.category==='toilet'?' selected':''}>Toilet</option>
          <option value="campground"${props.category==='campground'?' selected':''}>Campground</option>
          <option value="bike_shop"${props.category==='bike_shop'?' selected':''}>Bike shop</option>
          <option value="water"${props.category==='water'?' selected':''}>Water</option>
        </select>
      </label>
      <label>Notes <textarea id="poiNotes">${escapeHtml(props.notes||'')}</textarea></label>
      <div class="popup-actions">
        <button id="poiSave" class="btn">Save</button>
        <button id="poiDelete" class="deleteBtn">Delete</button>
      </div>
    </div>`;
    marker.bindPopup(html, { maxWidth:320 }).openPopup();
    marker.once('popupopen', () => {
      document.getElementById('poiSave').onclick = () => {
        props.name = document.getElementById('poiName').value;
        props.category = document.getElementById('poiCat').value;
        props.notes = document.getElementById('poiNotes').value;
        // move to correct category group
        Object.values(poiGroups).forEach(g => { if(g.hasLayer(marker)) g.removeLayer(marker); });
        poiGroups[props.category].addLayer(marker);
        refreshUserPoisMaster();
        marker.closePopup();
      };
      document.getElementById('poiDelete').onclick = () => {
        removeUserPoi(marker);
      };
    });
  });
}

function removeUserPoi(marker){
  Object.values(poiGroups).forEach(g => { if(g.hasLayer(marker)) g.removeLayer(marker); });
  if(userPoisLayer.hasLayer(marker)) userPoisLayer.removeLayer(marker);
  refreshUserPoisMaster();
}

function refreshUserPoisMaster(){
  userPoisLayer.clearLayers();
  Object.values(poiGroups).forEach(g => {
    g.eachLayer(l => userPoisLayer.addLayer(l));
  });
}

/* =========================
   Fetch toilets & campgrounds (Overpass)
   and show in clusters; auto-refresh on moveend
   ========================= */
async function fetchOverpass(query){
  const url = 'https://overpass-api.de/api/interpreter?data=' + encodeURIComponent(query);
  const resp = await fetch(url);
  return resp.json();
}

async function updateToilets(){
  const b = map.getBounds();
  const query = `[out:json][timeout:25];node["amenity"="toilets"](${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()});out;`;
  try{
    const json = await fetchOverpass(query);
    toiletsCluster.clearLayers();
    (json.elements || []).forEach(el => {
      if(!el.lat || !el.lon) return;
      const m = L.marker([el.lat, el.lon], { title: el.tags?.name || 'Public Toilet' });
      m.feature = { type:'Feature', properties: { layerType:'toilet', name: el.tags?.name || 'Public Toilet' }, geometry: { type:'Point', coordinates: [el.lon, el.lat] } };
      m.bindPopup(`<b>${escapeHtml(m.feature.properties.name)}</b>`);
      toiletsCluster.addLayer(m);
    });
  }catch(e){ console.warn('Toilet Overpass error', e); }
}

async function updateCamps(){
  const b = map.getBounds();
  const query = `[out:json][timeout:25];node["tourism"="camp_site"](${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()});out;`;
  try{
    const json = await fetchOverpass(query);
    campsCluster.clearLayers();
    (json.elements || []).forEach(el => {
      if(!el.lat || !el.lon) return;
      const m = L.marker([el.lat, el.lon], { title: el.tags?.name || 'Campground' });
      m.feature = { type:'Feature', properties: { layerType:'campground', name: el.tags?.name || 'Campground' }, geometry: { type:'Point', coordinates: [el.lon, el.lat] } };
      m.bindPopup(`<b>${escapeHtml(m.feature.properties.name)}</b>`);
      campsCluster.addLayer(m);
    });
  }catch(e){ console.warn('Camps Overpass error', e); }
}

// initial fetch & on moveend
map.on('moveend', () => {
  updateToilets();
  updateCamps();
});
updateToilets(); updateCamps();

/* =========================
   Filters & layer toggles
   ========================= */
function setVisible(layer, visible){
  if(visible){ if(!map.hasLayer(layer)) map.addLayer(layer); }
  else { if(map.hasLayer(layer)) map.removeLayer(layer); }
}

document.getElementById('toggleSegments').addEventListener('change', e => setVisible(segmentsLayer, e.target.checked));
document.getElementById('toggleUserPOIs').addEventListener('change', e => setVisible(userPoisLayer, e.target.checked));
document.getElementById('toggleToilets').addEventListener('change', e => setVisible(toiletsCluster, e.target.checked));
document.getElementById('toggleCamps').addEventListener('change', e => setVisible(campsCluster, e.target.checked));

// POI category filters
function applyPoiCategoryFilters(){
  const boxes = document.querySelectorAll('.poi-filter');
  const active = {};
  boxes.forEach(b => active[b.value] = b.checked);
  // user poi groups
  Object.keys(poiGroups).forEach(cat => {
    if(active[cat]) { if(!map.hasLayer(poiGroups[cat])) map.addLayer(poiGroups[cat]); }
    else { if(map.hasLayer(poiGroups[cat])) map.removeLayer(poiGroups[cat]); }
  });
  // fetched clusters: toilets -> category toilet, camps -> campground
  if(active['toilet']) { if(!map.hasLayer(toiletsCluster)) map.addLayer(toiletsCluster); }
  else { if(map.hasLayer(toiletsCluster)) map.removeLayer(toiletsCluster); }
  if(active['campground']) { if(!map.hasLayer(campsCluster)) map.addLayer(campsCluster); }
  else { if(map.hasLayer(campsCluster)) map.removeLayer(campsCluster); }
}
document.querySelectorAll('.poi-filter').forEach(cb => cb.addEventListener('change', applyPoiCategoryFilters));
applyPoiCategoryFilters();

/* =========================
   Search nearby (Overpass) for bike_shop or drinking_water
   ========================= */
document.getElementById('btnSearchNearby').addEventListener('click', async () => {
  const type = document.getElementById('searchType').value;
  const b = map.getBounds();
  // Overpass key: amenity=drinking_water for water; shop=bicycle or shop=bikes? use shop=bicycle and shop=bicycle_repair? we'll query bike_shop by tourism? use shop=bicycle and amenity=bicycle_rental and shop=bicycle_repair? But simplest: shop=bicycle and shop=bicycle_repair and shop=repair_bicycle and shop=bike_shop (some tags vary). We'll use shop=bicycle OR shop=bike OR shop=bicycle_repair OR shop=repair_bicycle OR shop=bicycle_shop OR shop=bike_shop
  let query;
  if(type === 'drinking_water'){
    query = `[out:json][timeout:25];node["amenity"="drinking_water"](${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()});out;`;
  } else { // bike_shop
    query = `[out:json][timeout:25];(node["shop"="bicycle"](${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()});node["shop"="bike_shop"](${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()});node["shop"="bicycle_repair"](${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}););out;`;
  }
  try{
    const json = await fetchOverpass(query);
    searchCluster.clearLayers();
    (json.elements || []).forEach(el => {
      if(!el.lat || !el.lon) return;
      const m = L.marker([el.lat, el.lon], { draggable: true });
      const name = el.tags?.name || (type === 'drinking_water' ? 'Water source' : 'Bike shop');
      m.feature = { type:'Feature', properties: { category: (type==='drinking_water' ? 'water' : 'bike_shop'), name }, geometry: { type:'Point', coordinates:[el.lon, el.lat] } };
      m.bindPopup(`<b>${escapeHtml(name)}</b><div class="popup-actions"><button class="btn" id="saveToUser">Add to my POIs</button></div>`);
      m.on('popupopen', () => {
        const btn = document.getElementById('saveToUser');
        if(btn) btn.onclick = () => {
          addUserPOI(m.getLatLng(), m.feature.properties.category, { name });
          searchCluster.removeLayer(m);
        };
      });
      searchCluster.addLayer(m);
    });
    map.addLayer(searchCluster);
    if((json.elements || []).length === 0) alert('No results found in the current map view.');
  }catch(e){ console.warn('Search Overpass failure', e); alert('Search failed'); }
});

/* =========================
   Persistence: save/load/export/import all user data
   - segments (GeoJSON)
   - user POIs (GeoJSON)
   ========================= */
function collectDataForSave(){
  const segs = segmentsLayer.toGeoJSON();
  const pois = userPoisLayer.toGeoJSON();
  return { segments: segs, pois: pois };
}
document.getElementById('btnSave').onclick = () => {
  const data = collectDataForSave();
  localStorage.setItem('cycling_map_data_v1', JSON.stringify(data));
  alert('Saved to localStorage.');
};
document.getElementById('btnLoad').onclick = () => {
  const raw = localStorage.getItem('cycling_map_data_v1');
  if(!raw){ alert('No saved data in localStorage.'); return; }
  try{
    const data = JSON.parse(raw);
    loadDataIntoMap(data);
    alert('Loaded from localStorage.');
  }catch(e){ alert('Failed to load.'); }
};
document.getElementById('btnExportAll').onclick = () => {
  const data = collectDataForSave();
  const blob = new Blob([JSON.stringify(data, null, 2)], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'cycling_map_data.json'; a.click(); URL.revokeObjectURL(url);
};
document.getElementById('importFile').onchange = (ev) => {
  const f = ev.target.files[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = e => {
    try{
      const data = JSON.parse(e.target.result);
      loadDataIntoMap(data);
      alert('Imported data.');
    }catch(err){ alert('Invalid file'); }
  };
  r.readAsText(f);
};

function loadDataIntoMap(data){
  // clear existing
  segmentsLayer.clearLayers();
  Object.values(poiGroups).forEach(g => g.clearLayers());
  userPoisLayer.clearLayers();

  // load segments
  if(data.segments && data.segments.features){
    L.geoJSON(data.segments, {
      onEachFeature: (feature, layer) => {
        // layer may be a polyline
        layer.feature = feature;
        const rank = feature.properties && feature.properties.rank ? feature.properties.rank : 'good';
        layer.setStyle(styleForRank(rank));
        segmentsLayer.addLayer(layer);
        // if geometry is available, compute elevation for popup (async)
        const coords = (feature.geometry && feature.geometry.coordinates) ? feature.geometry.coordinates.map(c => [c[1], c[0]]) : null;
        if(coords){
          computeElevationForCoords(coords).then(stats => {
            bindSegmentPopupWithChart(layer, ((feature.properties && feature.properties.distance_km) ? feature.properties.distance_km : 'â€”'), stats);
          });
        } else {
          bindSegmentPopupWithChart(layer, (feature.properties && feature.properties.distance_km) ? feature.properties.distance_km : 'â€”', { elevations:[], distances:[], sampled:[], gain:0, loss:0 });
        }
      }
    });
  }

  // load POIs
  if(data.pois && data.pois.features){
    data.pois.features.forEach(f => {
      const coords = f.geometry && f.geometry.coordinates ? [f.geometry.coordinates[1], f.geometry.coordinates[0]] : null;
      const props = f.properties || {};
      if(coords){
        const cat = props.category || 'bike_shop';
        addUserPOI(L.latLng(coords[0], coords[1]), cat, props);
      }
    });
  }
}

/* =========================
   Make sure user POIs are visible per toggles initially
   ========================= */
document.getElementById('toggleUserPOIs').addEventListener('change', e => setVisible(userPoisLayer, e.target.checked));
document.getElementById('toggleToilets').addEventListener('change', e => setVisible(toiletsCluster, e.target.checked));
document.getElementById('toggleCamps').addEventListener('change', e => setVisible(campsCluster, e.target.checked));
document.getElementById('toggleSegments').addEventListener('change', e => setVisible(segmentsLayer, e.target.checked));

/* =========================
   Load local data on start if present
   ========================= */
if(localStorage.getItem('cycling_map_data_v1')){
  try{
    const parsed = JSON.parse(localStorage.getItem('cycling_map_data_v1'));
    loadDataIntoMap(parsed);
  }catch(e){ console.warn('Failed to load local data at startup', e); }
}

/* =========================
   Final notes: UX improvements
   - clicking segments opens popup for rank/delete/edit
   - user can drag POIs (draggable). On dragend we update feature coords
   ========================= */
map.on('layeradd', () => {
  // keep clusters / layers consistent
});

/* =========================
   Done
   ========================= */
console.log('Cycling map loaded with full feature set.');
</script>
</body>
</html>
